//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
/// \file OpNovice/src/OpNoviceDetectorConstruction.cc
/// \brief Implementation of the OpNoviceDetectorConstruction class
//
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
#include "OpNoviceDetectorConstruction.hh"
#include "OpNoviceDetectorMessenger.hh"

#include "G4Box.hh"
#include "G4Element.hh"
#include "G4GDMLParser.hh"
#include "G4LogicalBorderSurface.hh"
#include "G4LogicalSkinSurface.hh"
#include "G4LogicalVolume.hh"
#include "G4Material.hh"
#include "G4OpticalSurface.hh"
#include "G4PVPlacement.hh"
#include "G4SystemOfUnits.hh"
#include "G4ThreeVector.hh"
#include "G4TwoVector.hh"
#include "G4NistManager.hh"
#include "G4MaterialPropertiesTable.hh"
#include "G4Navigator.hh"
#include "G4UnionSolid.hh"
#include "G4SubtractionSolid.hh"
#include "G4PhysicalConstants.hh"
#include "G4UIcommand.hh"
#include "G4ExtrudedSolid.hh"

#include "G4GeometryTolerance.hh"
#include "G4GeometryManager.hh"

#include "parameterlist.hh"
#include "G4PhysicalConstants.hh"



//黄清芳
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
OpNoviceDetectorConstruction::OpNoviceDetectorConstruction()
  : G4VUserDetectorConstruction()
{
  fDumpGdmlFileName = "OpNovice_dump.gdml";
  fVerbose          = false;
  fDumpGdml         = false;
  // create a messenger for this class
  fDetectorMessenger = new OpNoviceDetectorMessenger(this);
  fWorld_x = fWorld_y = fWorld_z = 100.0 * m;
  fExpHall_x = fExpHall_y = fExpHall_z = 10.0 * m;
  fTank_x = fTank_y = fTank_z = 5.0 * m;
  fBubble_x = fBubble_y = fBubble_z = 0.5 * m;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
OpNoviceDetectorConstruction::~OpNoviceDetectorConstruction()
{
  delete fDetectorMessenger;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
G4VPhysicalVolume* OpNoviceDetectorConstruction::Construct()
{
  

  G4bool checkOverlaps = true;
  // ------------- Materials -------------
  // G4double a, z, density;
  // G4int nelements;

  // // Air
  // G4Element* N = new G4Element("Nitrogen", "N", z = 7, a = 14.01 * g / mole);
  // G4Element* O = new G4Element("Oxygen", "O", z = 8, a = 16.00 * g / mole);
  // G4Material* air =
  //   new G4Material("Air", density = 1.29 * mg / cm3, nelements = 2);
  // air->AddElement(N, 70. * perCent);
  // air->AddElement(O, 30. * perCent);
  // //
  // // Water
  // G4Element* H = new G4Element("Hydrogen", "H", z = 1, a = 1.01 * g / mole);
  // G4Material* water =
  //   new G4Material("Water", density = 1.0 * g / cm3, nelements = 2);
  // water->AddElement(H, 2);
  // water->AddElement(O, 1);

//   // ------------ Generate && Add Material Properties Table ------------
//   //
//   std::vector<G4double> photonEnergy = {
//     2.034 * eV, 2.068 * eV, 2.103 * eV, 2.139 * eV, 2.177 * eV, 2.216 * eV,
//     2.256 * eV, 2.298 * eV, 2.341 * eV, 2.386 * eV, 2.433 * eV, 2.481 * eV,
//     2.532 * eV, 2.585 * eV, 2.640 * eV, 2.697 * eV, 2.757 * eV, 2.820 * eV,
//     2.885 * eV, 2.954 * eV, 3.026 * eV, 3.102 * eV, 3.181 * eV, 3.265 * eV,
//     3.353 * eV, 3.446 * eV, 3.545 * eV, 3.649 * eV, 3.760 * eV, 3.877 * eV,
//     4.002 * eV, 4.136 * eV
//   };

//   // WaterProperties
//   std::vector<G4double> refractiveIndex1 = {
//     1.3435, 1.344,  1.3445, 1.345,  1.3455, 1.346,  1.3465, 1.347,
//     1.3475, 1.348,  1.3485, 1.3492, 1.35,   1.3505, 1.351,  1.3518,
//     1.3522, 1.3530, 1.3535, 1.354,  1.3545, 1.355,  1.3555, 1.356,
//     1.3568, 1.3572, 1.358,  1.3585, 1.359,  1.3595, 1.36,   1.3608
//   };
//   std::vector<G4double> absorption = {
//     3.448 * m,  4.082 * m,  6.329 * m,  9.174 * m,  12.346 * m, 13.889 * m,
//     15.152 * m, 17.241 * m, 18.868 * m, 20.000 * m, 26.316 * m, 35.714 * m,
//     45.455 * m, 47.619 * m, 52.632 * m, 52.632 * m, 55.556 * m, 52.632 * m,
//     52.632 * m, 47.619 * m, 45.455 * m, 41.667 * m, 37.037 * m, 33.333 * m,
//     30.000 * m, 28.500 * m, 27.000 * m, 24.500 * m, 22.000 * m, 19.500 * m,
//     17.500 * m, 14.500 * m
//   };

//   // Material properties can be added as arrays. However, in this case it is
//   // up to the user to make sure both arrays have the same number of elements.
//   G4double scintilFastArray[]{ 1.0, 1.0 };
//   G4double energyArray[]{ 2.034 * eV, 4.136 * eV };
//   G4int lenArray = 2;

//   std::vector<G4double> scintilSlow = {
//     0.01, 1.00, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00, 9.00, 8.00,
//     7.00, 6.00, 4.00, 3.00, 2.00, 1.00, 0.01, 1.00, 2.00, 3.00, 4.00,
//     5.00, 6.00, 7.00, 8.00, 9.00, 8.00, 7.00, 6.00, 5.00, 4.00
//   };

//   G4MaterialPropertiesTable* myMPT1 = new G4MaterialPropertiesTable();

//   // Values can be added to the material property table individually.
//   // With this method, spline interpolation cannot be set. Arguments
//   // createNewKey and spline both take their default values of false.
//   // Need to specify the number of entries (1) in the arrays, as an argument
//   // to AddProperty.
//   G4int numEntries = 1;
//   myMPT1->AddProperty("RINDEX", &&photonEnergy[0], &&refractiveIndex1[0],
//                       numEntries);

//   for(size_t i = 1; i < photonEnergy.size(); ++i)
//   {
//     myMPT1->AddEntry("RINDEX", photonEnergy[i], refractiveIndex1[i]);
//   }

//   // Check that group velocity is calculated from RINDEX
//   if(myMPT1->GetProperty("RINDEX")->GetVectorLength() !=
//      myMPT1->GetProperty("GROUPVEL")->GetVectorLength())
//   {
//     G4ExceptionDescription ed;
//     ed << "Error calculating group velocities. Incorrect number of entries "
//           "in group velocity material property vector.";
//     G4Exception("OpNovice::OpNoviceDetectorConstruction", "OpNovice001",
//                 FatalException, ed);
//   }

//   // Adding a property from two std::vectors. Argument createNewKey is false
//   // and spline is true.
//   myMPT1->AddProperty("ABSLENGTH", photonEnergy, absorption, false, true);

//   // Adding a property using a C-style array.
//   // Spline interpolation isn't used for scintillation.
//   // Arguments spline and createNewKey both take default value false.
//   myMPT1->AddProperty("SCINTILLATIONCOMPONENT1", energyArray, scintilFastArray,
//                       lenArray);

//   myMPT1->AddProperty("SCINTILLATIONCOMPONENT2", photonEnergy, scintilSlow,
//                       false, true);
//   myMPT1->AddConstProperty("SCINTILLATIONYIELD", 50. / MeV);
//   myMPT1->AddConstProperty("RESOLUTIONSCALE", 1.0);
//   myMPT1->AddConstProperty("SCINTILLATIONTIMECONSTANT1", 1. * ns);
//   myMPT1->AddConstProperty("SCINTILLATIONTIMECONSTANT2", 10. * ns);
//   myMPT1->AddConstProperty("SCINTILLATIONYIELD1", 0.8);
//   myMPT1->AddConstProperty("SCINTILLATIONYIELD2", 0.2);
//   std::vector<G4double> energy_water = {
//     1.56962 * eV, 1.58974 * eV, 1.61039 * eV, 1.63157 * eV, 1.65333 * eV,
//     1.67567 * eV, 1.69863 * eV, 1.72222 * eV, 1.74647 * eV, 1.77142 * eV,
//     1.7971 * eV,  1.82352 * eV, 1.85074 * eV, 1.87878 * eV, 1.90769 * eV,
//     1.93749 * eV, 1.96825 * eV, 1.99999 * eV, 2.03278 * eV, 2.06666 * eV,
//     2.10169 * eV, 2.13793 * eV, 2.17543 * eV, 2.21428 * eV, 2.25454 * eV,
//     2.29629 * eV, 2.33962 * eV, 2.38461 * eV, 2.43137 * eV, 2.47999 * eV,
//     2.53061 * eV, 2.58333 * eV, 2.63829 * eV, 2.69565 * eV, 2.75555 * eV,
//     2.81817 * eV, 2.88371 * eV, 2.95237 * eV, 3.02438 * eV, 3.09999 * eV,
//     3.17948 * eV, 3.26315 * eV, 3.35134 * eV, 3.44444 * eV, 3.54285 * eV,
//     3.64705 * eV, 3.75757 * eV, 3.87499 * eV, 3.99999 * eV, 4.13332 * eV,
//     4.27585 * eV, 4.42856 * eV, 4.59258 * eV, 4.76922 * eV, 4.95999 * eV,
//     5.16665 * eV, 5.39129 * eV, 5.63635 * eV, 5.90475 * eV, 6.19998 * eV
//   };

//   // Rayleigh scattering length is calculated by G4OpRayleigh

//   // Mie: assume 100 times larger than the rayleigh scattering
//   std::vector<G4double> mie_water = {
//     167024.4 * m, 158726.7 * m, 150742 * m,   143062.5 * m, 135680.2 * m,
//     128587.4 * m, 121776.3 * m, 115239.5 * m, 108969.5 * m, 102958.8 * m,
//     97200.35 * m, 91686.86 * m, 86411.33 * m, 81366.79 * m, 76546.42 * m,
//     71943.46 * m, 67551.29 * m, 63363.36 * m, 59373.25 * m, 55574.61 * m,
//     51961.24 * m, 48527.00 * m, 45265.87 * m, 42171.94 * m, 39239.39 * m,
//     36462.50 * m, 33835.68 * m, 31353.41 * m, 29010.30 * m, 26801.03 * m,
//     24720.42 * m, 22763.36 * m, 20924.88 * m, 19200.07 * m, 17584.16 * m,
//     16072.45 * m, 14660.38 * m, 13343.46 * m, 12117.33 * m, 10977.70 * m,
//     9920.416 * m, 8941.407 * m, 8036.711 * m, 7202.470 * m, 6434.927 * m,
//     5730.429 * m, 5085.425 * m, 4496.467 * m, 3960.210 * m, 3473.413 * m,
//     3032.937 * m, 2635.746 * m, 2278.907 * m, 1959.588 * m, 1675.064 * m,
//     1422.710 * m, 1200.004 * m, 1004.528 * m, 833.9666 * m, 686.1063 * m
//   };

//   // Mie: gforward, gbackward, forward backward ratio
//   G4double mie_water_const[3] = { 0.99, 0.99, 0.8 };

//   myMPT1->AddProperty("MIEHG", energy_water, mie_water, false, true);
//   myMPT1->AddConstProperty("MIEHG_FORWARD", mie_water_const[0]);
//   myMPT1->AddConstProperty("MIEHG_BACKWARD", mie_water_const[1]);
//   myMPT1->AddConstProperty("MIEHG_FORWARD_RATIO", mie_water_const[2]);

//   G4cout << "Water G4MaterialPropertiesTable:" << G4endl;
//   myMPT1->DumpTable();

//   water->SetMaterialPropertiesTable(myMPT1);

//   // Set the Birks Constant for the Water scintillator
//   water->GetIonisation()->SetBirksConstant(0.126 * mm / MeV);

//   // Air
//   std::vector<G4double> refractiveIndex2 = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
//                                              1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
//                                              1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
//                                              1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
//                                              1.0, 1.0, 1.0, 1.0 };

//   G4MaterialPropertiesTable* myMPT2 = new G4MaterialPropertiesTable();
//   myMPT2->AddProperty("RINDEX", photonEnergy, refractiveIndex2);

//   G4cout << "Air G4MaterialPropertiesTable:" << G4endl;
//   myMPT2->DumpTable();

//   air->SetMaterialPropertiesTable(myMPT2);

  // ------------- Volumes --------------
  //
  // The world===========================================================================================================================================
  // G4Box* world_box = new G4Box("World", fWorld_x, fWorld_y, fWorld_z);
  // G4LogicalVolume* world_log =
  //   new G4LogicalVolume(world_box, air, "World", 0, 0, 0);
  // G4VPhysicalVolume* world_phys = new G4PVPlacement(
  //   0, G4ThreeVector(), world_log, "world", 0, false, 0, checkOverlaps);

  // G4double R = 10. * m;
  // G4double Rin = 0.8*R;

  // std::vector<G4TwoVector> outtwovector(numOfEdges);
  // std::vector<G4TwoVector> intwovector(numOfEdges);
  // std::vector<G4ExtrudedSolid::ZSection> zSection = {G4ExtrudedSolid::ZSection(10*m, G4TwoVector(0., 0.), 1.), 
  //       G4ExtrudedSolid::ZSection(20.*m, G4TwoVector(1*m, 1*m), 0.8),G4ExtrudedSolid::ZSection(30.*m, G4TwoVector(1.*m, 1.*m), 1.)};
  // std::vector<G4ExtrudedSolid::ZSection> zSection1 = {G4ExtrudedSolid::ZSection(10*m - 1 * mm, G4TwoVector(0., 0.), 1), 
  //       G4ExtrudedSolid::ZSection(20.*m, G4TwoVector(1*m, 1*m), 0.8),G4ExtrudedSolid::ZSection(30.*m, G4TwoVector(1.*m, 1.*m), 1.)};
  // // zSection(0) = G4ExtrudedSolid::ZSection(5.*m, G4TwoVector(0., 0.), 1.);

  // for(int i =0; i < numOfEdges; i++)
  // {
  //   outtwovector[i] = G4TwoVector(R * std::cos(i*360/numOfEdges*deg), R * std::sin(i*360/numOfEdges*deg));
  //   intwovector[i] = G4TwoVector(Rin * std::cos(i*360/numOfEdges*deg), Rin * std::sin(i*360/numOfEdges*deg));
  // }

  // G4ExtrudedSolid* Solidout = new G4ExtrudedSolid("myoutExtrudedSolid", outtwovector, zSection);
  // G4ExtrudedSolid* Solidin = new G4ExtrudedSolid("myinExtrudedSolid", intwovector, zSection1);

  // G4double innerRadius1 = 5. * m;
  // G4double outerRadius1 = 10. * m;
  // G4double height1 = 10. * m;
  // G4Tubs* cylinder1 = new G4Tubs("Cylinder1", innerRadius1, outerRadius1, height1/2.0, 0.0, 360.0 * deg);

  // G4double innerRadius2 = 0 * m;
  // G4double outerRadius2 = 10.01 * m;
  // G4double height2 = 10.01 * m;
  // G4Tubs* cylinder2 = new G4Tubs("Cylinder2", innerRadius1, outerRadius1, height1/2.0, 0.0, 180 * deg);
  // G4Tubs* cylinder3 = new G4Tubs("Cylinder4", innerRadius1, outerRadius1, height1/2.0, 0.0, 360.0 * deg);

  // G4RotationMatrix* rotationMatrix = new G4RotationMatrix();
  // G4RotationMatrix* rotationMatrix1 = new G4RotationMatrix();
  // G4double rotationAngle = -5 * deg; // 设置旋转角度
  // // rotationMatrix->rotateZ(rotationAngle); // 绕Y轴旋转
  // rotationMatrix->rotateY(std::atan(std::sqrt(3))); // 绕Y轴旋转
  
  // G4cout << "~~~~~~~~~~~~~~~~~_XIEGUOYU_Angle is: " << std::atan(std::sqrt(3)) << G4endl;



  // G4UnionSolid* combinedCylinder = new G4UnionSolid("CombinedCylinder", cylinder1, cylinder2,
  //      rotationMatrix, G4ThreeVector(10 * m,10*m,20 * m));
  // // 创建逻辑体


  // // 放置在位置
  // G4double posX = 0.0;
  // G4double posY = 0.0;
  // G4double posZ = 0.0;

  // rotationMatrix->rotateX(2*rotationAngle);
  // cylinder2 = new G4Tubs("Cylinder3", innerRadius1, outerRadius1, height1/2.0, 0.0, 360.0 * deg);

  // combinedCylinder = new G4UnionSolid("CombinedCylinder", combinedCylinder, cylinder2,
  //      nullptr, G4ThreeVector(-10 * m ,-10 * m,30 * m));

  // G4SubtractionSolid* subCylinder = new G4SubtractionSolid("SubCylinder", Solidout, Solidin);
  // G4LogicalVolume* logicCombinedCylinder = new G4LogicalVolume(subCylinder, water, "CombinedCylinder");
  // G4PVPlacement* physicalCombinedCylinder = new G4PVPlacement(0, G4ThreeVector(posX, posY, posZ), 
  //       logicCombinedCylinder, "CombinedCylinder", world_log, checkOverlaps, 0);
  // delete cylinder2;
  // cylinder2 = nullptr;
  // delete combinedCylinder;
  // combinedCylinder = nullptr;  

  // // The experimental Hall
  // G4Box* expHall_box = new G4Box("expHall", fExpHall_x, fExpHall_y, fExpHall_z);
  // G4LogicalVolume* expHall_log =
  //   new G4LogicalVolume(expHall_box, air, "expHall", 0, 0, 0);
  // G4VPhysicalVolume* expHall_phys = new G4PVPlacement(
  //   0, G4ThreeVector(), expHall_log, "expHall", world_log, false, 0);

  // // The Water Tank
  // G4Box* waterTank_box = new G4Box("Tank", fTank_x, fTank_y, fTank_z);
  // G4LogicalVolume* waterTank_log =
  //   new G4LogicalVolume(waterTank_box, water, "Tank", 0, 0, 0);
  // G4VPhysicalVolume* waterTank_phys = new G4PVPlacement(
  //   0, G4ThreeVector(), waterTank_log, "Tank", expHall_log, false, 0);

  // // The Air Bubble
  // G4Box* bubbleAir_box = new G4Box("Bubble", fBubble_x, fBubble_y, fBubble_z);
  // G4LogicalVolume* bubbleAir_log =
  //   new G4LogicalVolume(bubbleAir_box, air, "Bubble", 0, 0, 0);
  // new G4PVPlacement(0, G4ThreeVector(0, 2.5 * m, 0), bubbleAir_log, "Bubble",
  //                   waterTank_log, false, 0);
  
  // The world========================================================================================================================================
  // // ------------- Surfaces --------------

  // // Water Tank
  // G4OpticalSurface* opWaterSurface = new G4OpticalSurface("WaterSurface");
  // opWaterSurface->SetType(dielectric_LUTDAVIS);
  // opWaterSurface->SetFinish(Rough_LUT);
  // opWaterSurface->SetModel(DAVIS);

  // G4LogicalBorderSurface* waterSurface = new G4LogicalBorderSurface(
  //   "WaterSurface", waterTank_phys, expHall_phys, opWaterSurface);

  // G4OpticalSurface* opticalSurface = dynamic_cast<G4OpticalSurface*>(
  //   waterSurface->GetSurface(waterTank_phys, expHall_phys)
  //     ->GetSurfaceProperty());
  // if(opticalSurface)
  //   opticalSurface->DumpInfo();

  // // Air Bubble
  // G4OpticalSurface* opAirSurface = new G4OpticalSurface("AirSurface");
  // opAirSurface->SetType(dielectric_dielectric);
  // opAirSurface->SetFinish(polished);
  // opAirSurface->SetModel(glisur);

  // G4LogicalSkinSurface* airSurface =
  //   new G4LogicalSkinSurface("AirSurface", bubbleAir_log, opAirSurface);

  // opticalSurface = dynamic_cast<G4OpticalSurface*>(
  //   airSurface->GetSurface(bubbleAir_log)->GetSurfaceProperty());
  // if(opticalSurface)
  //   opticalSurface->DumpInfo();

  // // Generate && Add Material Properties Table attached to the optical surfaces
  // //
  // std::vector<G4double> ephoton = { 2.034 * eV, 4.136 * eV };

  // // OpticalAirSurface
  // std::vector<G4double> reflectivity = { 0.3, 0.5 };
  // std::vector<G4double> efficiency   = { 0.8, 1.0 };

  // G4MaterialPropertiesTable* myST2 = new G4MaterialPropertiesTable();

  // myST2->AddProperty("REFLECTIVITY", ephoton, reflectivity);//是什么情况下的能量反射率的数组
  // myST2->AddProperty("EFFICIENCY", ephoton, efficiency);
  // if(fVerbose)
  // {
  //   G4cout << "Air Surface G4MaterialPropertiesTable:" << G4endl;
  //   myST2->DumpTable();
  // }
  // opAirSurface->SetMaterialPropertiesTable(myST2);

  // if(fDumpGdml)
  // {
  //   G4GDMLParser* parser = new G4GDMLParser();
  //   parser->Write(fDumpGdmlFileName, world_phys);
  // }

  // ////////////////////////////////////////////////////////////////////////////
  // // test user-defined properties
  // G4String ed;
  // if(myMPT1->GetProperty("USERDEFINED") != nullptr)
  // {
  //   ed = "USERDEFINED != nullptr";
  //   PrintError(ed);
  // }
  // myMPT1->AddProperty("USERDEFINED", energy_water, mie_water, true, true);
  // if(myMPT1->GetProperty("USERDEFINED") == nullptr)
  // {
  //   ed = "USERDEFINED == nullptr";
  //   PrintError(ed);
  // }
  // [[maybe_unused]] G4int index_userdefined = -1;
  // if(myMPT1->GetProperty("USERDEFINED") != nullptr)
  // {
  //   index_userdefined = myMPT1->GetPropertyIndex("USERDEFINED");
  // }
  // if(!(index_userdefined >= 0 &&&&
  //       index_userdefined <
  //       (G4int) myMPT1->GetMaterialPropertyNames().size()))
  // {
  //   ed = "USERDEFINED index out of range";
  //   PrintError(ed);
  // }
  // myMPT1->RemoveProperty("USERDEFINED");
  // if(myMPT1->GetProperty("USERDEFINED") != nullptr)
  // {
  //   ed = "USERDEFINED != nullptr at end";
  //   PrintError(ed);
  // }

  // if(myMPT1->ConstPropertyExists("USERDEFINEDCONST") == true)
  // {
  //   ed = "ConstProperty USERDEFINEDCONST already exists.";
  //   PrintError(ed);
  // }
  // myMPT1->AddConstProperty("USERDEFINEDCONST", 3.14, true);
  // if(myMPT1->ConstPropertyExists("USERDEFINEDCONST") == false)
  // {
  //   ed = "ConstProperty USERDEFINEDCONST doesn't exist.";
  //   PrintError(ed);
  // }
  // [[maybe_unused]] G4int index_pi = -1;
  // if(myMPT1->ConstPropertyExists("USERDEFINEDCONST") == true)
  // {
  //   index_pi = myMPT1->GetConstPropertyIndex("USERDEFINEDCONST");
  // }
  // if (!(index_pi >= 0 &&&&
  //        index_pi < (G4int) myMPT1->GetMaterialConstPropertyNames().size()))
  // {
  //   ed = "ConstProperty USERDEFINEDCONST index out of range.";
  //   PrintError(ed);
  // }
  // myMPT1->RemoveConstProperty("USERDEFINEDCONST");
  // if (myMPT1->ConstPropertyExists("USERDEFINEDCONST") == true)
  // {
  //   ed = "ConstProperty USERDEFINEDCONST still exists.";
  //   PrintError(ed);
  // }
  // done testing user-defined properties
  ////////////////////////////////////////////////////////////////////////////
  DefineMaterials();
  return CXRP();
  // return world_phys;
}

// void OpNoviceDetectorConstruction::CopyParameters(G4double phi1, G4double phi2, G4double f ,G4double L )
// {

// }
// extern G4String fullLenth;
// extern G4String oiPhi;
// extern G4String ooPhi;
// extern G4String focalLenth;
// extern G4String diameterRadio;
//三次函数
G4double OpNoviceDetectorConstruction::CubicFunction(G4double z)
{
  G4double a = oiPhi / (focalLenth * fullLenth * fullLenth) - (2 * (ooPhi - oiPhi) / fullLenth / fullLenth / fullLenth);
  G4double b = -(oiPhi / (2 * focalLenth * fullLenth));
  G4double c = -(oiPhi / ( 4 * focalLenth)) + 3*(ooPhi - oiPhi) / 2 / fullLenth;
  G4double d = (oiPhi + ooPhi) / 2 + (oiPhi* fullLenth) / 8 / focalLenth;

  return a * z * z * z + b * z * z + c * z + d;
}

//三次函数导数
G4double OpNoviceDetectorConstruction::SlopeCubicFunction(G4double z)
{
  G4double a = oiPhi / (focalLenth * fullLenth * fullLenth) - (2 * (ooPhi - oiPhi) / fullLenth / fullLenth / fullLenth);
  G4double b = -(oiPhi / (2 * focalLenth * fullLenth));
  G4double c = -(oiPhi / ( 4 * focalLenth)) + 3*(ooPhi - oiPhi) / 2 / fullLenth;
  G4double d = (oiPhi + ooPhi) / 2 + (oiPhi* fullLenth) / 8 / focalLenth;
  return 3 * a * z * z + 2 * b * z + c;
}

//定义材料并且设置光学特性
void OpNoviceDetectorConstruction::DefineMaterials()
{
  // Material definition

  G4NistManager* nistManager = G4NistManager::Instance();

  // Air defined using NIST Manager   Galactic
  fWorldMaterial = nistManager->FindOrBuildMaterial("G4_AIR");

  // Lead defined using NIST Manager
  fLensMaterial  = nistManager->FindOrBuildMaterial("G4_Pyrex_Glass");

  fDetector = nistManager->FindOrBuildMaterial("G4_Si");

  fpinholeCollimatorMaterial = nistManager->FindOrBuildMaterial("G4_Pb");

  // Print materials
  G4cout << *(G4Material::GetMaterialTable()) << G4endl;

  // ------------ Generate && Add Material Properties Table ------------
  //PyrexMaterial
  std::vector<G4double> photonEnergy = {
    1000*eV, 1242.42*eV, 1484.85*eV, 1727.27*eV, 1969.7*eV, 2212.12*eV, 2454.55*eV, 2696.97*eV,
    2939.39*eV, 3181.82*eV, 3424.24*eV, 3666.67*eV, 3909.09*eV, 4151.52*eV, 4393.94*eV, 4636.36*eV,
    4878.79*eV, 5121.21*eV, 5363.64*eV, 5606.06*eV, 5848.48*eV, 6090.91*eV, 6333.33*eV, 6575.76*eV,
    6818.18*eV, 7060.61*eV, 7303.03*eV, 7545.45*eV, 7787.88*eV, 8030.3*eV, 8272.73*eV, 8515.15*eV,
    8757.58*eV, 9000*eV, 9242.42*eV, 9484.85*eV, 9727.27*eV, 9969.7*eV, 10212.1*eV, 10454.5*eV,
    10697*eV, 10939.4*eV, 11181.8*eV, 11424.2*eV, 11666.7*eV, 11909.1*eV, 12151.5*eV, 12393.9*eV,
    12636.4*eV, 12878.8*eV, 13121.2*eV, 13363.6*eV, 13606.1*eV, 13848.5*eV, 14090.9*eV, 14333.3*eV,
    14575.8*eV, 14818.2*eV, 15060.6*eV, 15303*eV, 15545.5*eV, 15787.9*eV, 16030.3*eV, 16272.7*eV,
    16515.2*eV, 16757.6*eV, 17000*eV, 17242.4*eV, 17484.8*eV, 17727.3*eV, 17969.7*eV, 18212.1*eV,
    18454.5*eV, 18697*eV, 18939.4*eV, 19181.8*eV, 19424.2*eV, 19666.7*eV, 19909.1*eV, 20151.5*eV,
    20393.9*eV, 20636.4*eV, 20878.8*eV, 21121.2*eV, 21363.6*eV, 21606.1*eV, 21848.5*eV, 22090.9*eV,
    22333.3*eV, 22575.8*eV, 22818.2*eV, 23060.6*eV, 23303*eV, 23545.5*eV, 23787.9*eV, 24030.3*eV,
    24272.7*eV, 24515.2*eV, 24757.6*eV, 25000*eV
  };
  // PyrexProperties - refraction
  std::vector<G4double> pyrexRefractiveIndex = {
    0.99954872, 0.99970685, 0.999796986, 0.99985449, 0.999885909, 0.999906153, 0.999922715,
    0.999935564, 0.999945579, 0.999953489, 0.999959828, 0.999964973, 0.999969185, 0.999972693,
    0.99997564, 0.999978137, 0.999980272, 0.999982109, 0.999983703, 0.999985093, 0.999986313,
    0.99998739, 0.999988344, 0.999989195, 0.999989955, 0.999990638, 0.999991254, 0.999991811,
    0.999992316, 0.999992776, 0.999993196, 0.99999358, 0.999993932, 0.999994255, 0.999994553,
    0.999994828, 0.999995076, 0.99999532, 0.999995546, 0.999995753, 0.999995946, 0.999996125,
    0.999996293, 0.99999645, 0.999996597, 0.999996735, 0.999996865, 0.999996987, 0.999997102,
    0.999997211, 0.999997314, 0.999997411, 0.999997503, 0.99999759, 0.999997672, 0.999997751,
    0.999997825, 0.999997896, 0.999997964, 0.999998028, 0.999998089, 0.999998147, 0.999998203,
    0.999998257, 0.999998308, 0.999998356, 0.999998403, 0.999998448, 0.999998491, 0.999998532,
    0.999998571, 0.999998609, 0.999998645, 0.99999868, 0.999998714, 0.999998746, 0.999998778,
    0.999998808, 0.999998837, 0.999998864, 0.999998891, 0.999998917, 0.999998942, 0.999998967,
    0.99999899, 0.999999013, 0.999999034, 0.999999055, 0.999999076, 0.999999096, 0.999999115,
    0.999999133, 0.999999151, 0.999999169, 0.999999186, 0.999999202, 0.999999218, 0.999999233,
    0.999999248, 0.999999263
  };

  //吸收长度
  std::ifstream inputFile1("AirAbsLengtht.txt");
  if (!inputFile1) 
  {
    G4cout << "无法打开AirAbsLengtht.txt文件！" << G4endl;
  }
  std::ifstream inputFile2("PyrexAbsLength.txt");
  if (!inputFile2) 
  {
    G4cout << "无法打开PyrexAbsLength.txt文件！" << G4endl;
  }
  //AbsLength
  std::vector<G4double> airOpticEnergy;
  std::vector<G4double> airOpticAbsLength;
  std::vector<G4double> pyrexOpticEnergy;
  std::vector<G4double> pyrexOpticAbsLength;

  std::string line;
  while (std::getline(inputFile2, line)) 
  {
    std::istringstream iss(line);
    G4double value;
    int currentColumn = 1;
    while (iss >> value) 
    {
      if (currentColumn == 1) //第一列为能量
      {
        pyrexOpticEnergy.push_back(value*eV);
      }
      else if(currentColumn == 2) //第二列为吸收长度
      {
        pyrexOpticAbsLength.push_back(value*cm);
      }
      currentColumn++;
    }
  }


  G4MaterialPropertiesTable* PyrexMPT = new G4MaterialPropertiesTable();
  PyrexMPT->AddProperty("RINDEX", photonEnergy, pyrexRefractiveIndex, false, true);
  PyrexMPT->AddProperty("ABSLENGTH", pyrexOpticEnergy, pyrexOpticAbsLength, false, true);

  // Check that group velocity is calculated from RINDEX
  if(PyrexMPT->GetProperty("RINDEX")->GetVectorLength() !=
     PyrexMPT->GetProperty("GROUPVEL")->GetVectorLength())
  {
    G4ExceptionDescription ed;
    ed << "Error calculating group velocities. Incorrect number of entries "
          "in group velocity material property vector.";
    G4Exception("OpNovice::OpNoviceDetectorConstruction", "OpNovice001",
                FatalException, ed);
  }

  G4cout << "Pyrex G4MaterialPropertiesTable:" << G4endl;
  PyrexMPT->DumpTable();

  fLensMaterial->SetMaterialPropertiesTable(PyrexMPT);

  // Air
  std::vector<G4double> airRefractiveIndex = { 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
                                             1.0, 1.0  };

  //PyrexAbsorbLength
  while (std::getline(inputFile1, line)) 
  {
    std::istringstream iss(line);
    G4double value;
    int currentColumn = 1;
    while (iss >> value) 
    {
      if (currentColumn == 1) //第一列为能量
      {
        airOpticEnergy.push_back(value*eV);
      }
      else if(currentColumn == 2) //第二列为吸收长度
      {
        airOpticAbsLength.push_back(value*cm);
      }
      currentColumn++;
    }
  }

  // G4cout << "Air Length:" << G4endl;
  // for (int i = 0; i < airOpticEnergy.size(); i++) 
  // {
  //   G4cout << airOpticEnergy[i] << " " << airOpticAbsLength[i] << G4endl;
  // }

  // G4cout << "Pyrex Length:" << G4endl;
  // for (int i = 0; i < pyrexOpticEnergy.size(); i++) 
  // {
  //   G4cout << pyrexOpticEnergy[i] << " " << pyrexOpticAbsLength[i] << G4endl;
  // }

  inputFile1.close();
  inputFile2.close();

  G4MaterialPropertiesTable* airMPT = new G4MaterialPropertiesTable();
  airMPT->AddProperty("RINDEX", photonEnergy, airRefractiveIndex);
  airMPT->AddProperty("ABSLENGTH", airOpticEnergy, airOpticAbsLength);

  G4cout << "Air G4MaterialPropertiesTable:" << G4endl;
  airMPT->DumpTable();

  fWorldMaterial->SetMaterialPropertiesTable(airMPT);
  fDetector->SetMaterialPropertiesTable(airMPT);
  fpinholeCollimatorMaterial->SetMaterialPropertiesTable(airMPT);
}

//构建多毛细管模型并设置边界
G4VPhysicalVolume* OpNoviceDetectorConstruction::CXRP()
{
  G4double height = fullLenth / n;
  // G4double slope = SlopeCubicFunction(-(fullLenth/2));
  // G4double angle = std::atan(slope);            //单管第一根微元的角度
  // G4RotationMatrix* rotationMatrix = new G4RotationMatrix();

  // std::vector<G4Tubs*> MicroTubs(n);
  // std::vector<G4LogicalVolume*> MicroTubsLV(n);

  //出口处VD0尺寸设定
  std::vector<G4double> vdAng = {180.*deg/6, 180.*deg/2, 180.*deg*5/6, 180.*deg*7/6, 180.*deg*3/2, 180.*deg*11/6};
  std::vector<G4TwoVector> vdtwovector(6);
  for(int i = 0; i < 6; i++)
    vdtwovector[i] = G4TwoVector(VDDiameter*std::cos(vdAng[i]), VDDiameter*std::sin(vdAng[i]));
  std::vector<G4ExtrudedSolid::ZSection> vdzSection = {G4ExtrudedSolid::ZSection(fullLenth/2, G4TwoVector(0,0), 1.), 
                                                        G4ExtrudedSolid::ZSection(fullLenth/2 + halfVDheight*2, G4TwoVector(0,0), 1.)};

  //单根管子有多少边
  std::vector<G4TwoVector> twovector1(numOfEdges);
  std::vector<G4TwoVector> twovector2(numOfEdges);
  //zSection单根管子横截面的ZSection
  std::vector<G4ExtrudedSolid::ZSection> zSection(n + 1);
  std::vector<G4ExtrudedSolid::ZSection> zSection1(n + 3);
  // zSection(0) = G4ExtrudedSolid::ZSection(5.*m, G4TwoVector(0., 0.), 1.);

  for(int i =0; i < numOfEdges; i++)
  {
    twovector1[i] = G4TwoVector(oiPhi/2 * std::cos(i*360/numOfEdges*deg), oiPhi/2 * std::sin(i*360/numOfEdges*deg));
    twovector2[i] = G4TwoVector(diameterRadio*oiPhi/2 * std::cos(i*360/numOfEdges*deg), diameterRadio*oiPhi/2 * std::sin(i*360/numOfEdges*deg));
    G4cout << "oiPhi/2 * std::cos(i*360/numOfEdges*deg)=" << oiPhi/2 * std::cos(i*360/numOfEdges*deg)
      <<"       oiPhi/2 * std::sin(i*360/numOfEdges*deg)=" << oiPhi/2 * std::sin(i*360/numOfEdges*deg) << G4endl;
    G4cout << "diameterRadio*oiPhi/2 * std::cos(i*360/numOfEdges*deg)=" << diameterRadio*oiPhi/2 * std::cos(i*360/numOfEdges*deg)
        <<"       diameterRadio*oiPhi/2 * std::sin(i*360/numOfEdges*deg)=" << diameterRadio*oiPhi/2 * std::sin(i*360/numOfEdges*deg) << G4endl;
  } 

  //计算每一Layer的Ck
  G4double c1 = std::sqrt(3)*numberOfmonocapillaries + 1;
  G4double c2[2] = {2*(std::sqrt(3)*numberOfmonocapillaries + 1), std::sqrt(3)*(std::sqrt(3)*numberOfmonocapillaries + 1)};
  G4double c3[2] = {3*(std::sqrt(3)*numberOfmonocapillaries + 1), std::sqrt(7)*(std::sqrt(3)*numberOfmonocapillaries + 1)};
  G4double c4[3] = {4*(std::sqrt(3)*numberOfmonocapillaries + 1), std::sqrt(13)*(std::sqrt(3)*numberOfmonocapillaries + 1), 
                        std::sqrt(12)*(std::sqrt(3)*numberOfmonocapillaries + 1)};
  G4double c5[3] = {5*(std::sqrt(3)*numberOfmonocapillaries + 1), std::sqrt(21)*(std::sqrt(3)*numberOfmonocapillaries + 1), 
                        std::sqrt(19)*(std::sqrt(3)*numberOfmonocapillaries + 1)};
  G4double c6[4] = {6*(std::sqrt(3)*numberOfmonocapillaries + 1), std::sqrt(31)*(std::sqrt(3)*numberOfmonocapillaries + 1), 
                        std::sqrt(28)*(std::sqrt(3)*numberOfmonocapillaries + 1), std::sqrt(27)*(std::sqrt(3)*numberOfmonocapillaries + 1)};

  //单独罗列的正六边形的极角
  G4double theta31, theta62, theta41, theta51, theta52, theta61;
  theta31 = theta62 = std::atan(std::sqrt(3)/9);
  theta41 = std::atan(std::sqrt(3)/6);
  theta51 = std::atan(std::sqrt(3)/5);
  theta52 = std::atan(std::sqrt(3)/15);
  theta61 = std::atan(std::sqrt(12)/9);

  // if(focalLenth >= distanceVD1andVD2)
  //   worldhZ = fullLenth/2 + focalLenth;
  // else if(focalLenth < distanceVD1andVD2)
  //   worldhZ = fullLenth/2 + distanceVD1andVD2;
  worldhZ = fullLenth/2 + std::max({distanceVD1andVD2, focalLenth, (sixDistance + gapSize)});

  // worldhZ = fullLenth*1.2/2;
  // worldhX = worldhY = 352. * um;
  
  // G4GeometryManager::GetInstance()->SetWorldMaximumExtent(worldhZ);

  // G4cout << "Computed tolerance = "
  //        << G4GeometryTolerance::GetInstance()->GetSurfaceTolerance()/mm
  //        << " mm" << G4endl;

  auto worldS = new G4Box("world", worldhX, worldhY, worldhZ);  
  auto worldLV = new G4LogicalVolume(worldS, fWorldMaterial, "World");                             
  auto worldPV = new G4PVPlacement(0,
                  G4ThreeVector(),
                  worldLV,
                  "World",
                  0,
                  false,         
                  0,    
                  fCheckOverlaps);

  //detector1
  auto VD1_solid = new G4ExtrudedSolid("VD1_solid", vdtwovector, vdzSection);
  auto VD1_LV = new G4LogicalVolume(VD1_solid, fDetector, "VD1_LV");
  auto VD1_PV = new G4PVPlacement(0,
                  G4ThreeVector(0,0,fullLenth/2 + halfVDheight),
                  VD1_LV,
                  "VD1_PV",
                  worldLV,
                  false,         
                  0,    
                  fCheckOverlaps);
  
  // //detector2
  // auto VD2_solid = new G4Tubs("VD2", 0, VDDiameter/2, halfVDheight, 0. * deg, 360. * deg);
  // auto VD2_LV = new G4LogicalVolume(VD2_solid, fWorldMaterial, "VD2_LV");
  // auto VD2_PV = new G4PVPlacement(0,
  //                 G4ThreeVector(0,0,fullLenth/2 + halfVDheight + secDistance),
  //                 VD2_LV,
  //                 "VD2_PV",
  //                 worldLV,
  //                 false,         
  //                 0,    
  //                 fCheckOverlaps);

  // //detector3
  // auto VD3_solid = new G4Tubs("VD3", 0, VDDiameter/2, halfVDheight, 0. * deg, 360. * deg);
  // auto VD3_LV = new G4LogicalVolume(VD3_solid, fWorldMaterial, "VD3_LV");
  // auto VD3_PV = new G4PVPlacement(0,
  //                 G4ThreeVector(0,0,fullLenth/2 + halfVDheight + thiDistance),
  //                 VD3_LV,
  //                 "VD3_PV",
  //                 worldLV,
  //                 false,         
  //                 0,    
  //                 fCheckOverlaps);

  // //detector4
  // auto VD4_solid = new G4Tubs("VD4", 0, VDDiameter/2, halfVDheight, 0. * deg, 360. * deg);
  // auto VD4_LV = new G4LogicalVolume(VD4_solid, fWorldMaterial, "VD4_LV");
  // auto VD4_PV = new G4PVPlacement(0,
  //                 G4ThreeVector(0,0,fullLenth/2 + halfVDheight + forDistance),
  //                 VD4_LV,
  //                 "VD4_PV",
  //                 worldLV,
  //                 false,         
  //                 0,    
  //                 fCheckOverlaps);

  // //detector5
  // auto VD5_solid = new G4Tubs("VD5", 0, VDDiameter/2, halfVDheight, 0. * deg, 360. * deg);
  // auto VD5_LV = new G4LogicalVolume(VD5_solid, fWorldMaterial, "VD5_LV");
  // auto VD5_PV = new G4PVPlacement(0,
  //                 G4ThreeVector(0,0,fullLenth/2 + halfVDheight + fitDistance),
  //                 VD5_LV,
  //                 "VD5_PV",
  //                 worldLV,
  //                 false,         
  //                 0,    
  //                 fCheckOverlaps);

  // //detector6
  // auto VD6_solid = new G4Tubs("VD6", 0, VDDiameter/2, halfVDheight, 0. * deg, 360. * deg);
  // auto VD6_LV = new G4LogicalVolume(VD6_solid, fWorldMaterial, "VD6_LV");
  // auto VD6_PV = new G4PVPlacement(0,
  //                 G4ThreeVector(0,0,fullLenth/2 + halfVDheight + sixDistance),
  //                 VD6_LV,
  //                 "VD6_PV",
  //                 worldLV,
  //                 false,         
  //                 0,    
  //                 fCheckOverlaps);

  //Pinhole Collimator
  auto pinholeCollimatorBox_solid = new G4Box("world", worldhX, worldhY, halfPinholeCollimatorHeight);
  auto pinholeCollimatorTubs_solid = new G4Tubs("pinholeCollimator", 0, inpinholeCollimatorDiamater/2, halfPinholeCollimatorHeight + 1.*um, 0. * deg, 360. * deg);

  G4SubtractionSolid* pinholeCollimator = new G4SubtractionSolid("PinholeCollimator", pinholeCollimatorBox_solid, pinholeCollimatorTubs_solid);
  auto pinholeCollimator_LV = new G4LogicalVolume(pinholeCollimator, fpinholeCollimatorMaterial, "pinholeCollimator_LV");
  auto pinholeCollimator_PV = new G4PVPlacement(0,
                                G4ThreeVector(0,0,-fullLenth/2 - halfPinholeCollimatorHeight),
                                pinholeCollimator_LV,
                                "pinholeCollimator_PV",
                                worldLV,
                                false,         
                                0,    
                                fCheckOverlaps);

  fScoringVolume = VD1_LV;

  std::vector<G4double> pyrexOpticEnergy;
  std::vector<G4double> pyrexRefraction_RealRindex;
  std::vector<G4double> pyrexRefraction_ImaginaryRindex;

  //虚实部
  //实部
  std::ifstream inputFile1("Pyrex_refraction_delta.txt");
  if (!inputFile1) 
  {
    G4cout << "无法打开Pyrex_refraction_delta.txt文件！" << G4endl;
  }
  //虚部
  std::ifstream inputFile2("Pyrex_refraction_beta.txt");
  if (!inputFile2) 
  {
    G4cout << "无法打开Pyrex_refraction_beta.txt文件！" << G4endl;
  }

  std::string line;
  while (std::getline(inputFile1, line)) 
  {
    std::istringstream iss(line);
    G4double value;
    int currentColumn = 1;
    while (iss >> value) 
    {
      if (currentColumn == 1) //第一列为能量
      {
        pyrexOpticEnergy.push_back(value*eV);
      }
      else if(currentColumn == 2) //第二列为吸收长度
      {
        pyrexRefraction_RealRindex.push_back(1 - value);
      }
      currentColumn++;
    }
  }

  while (std::getline(inputFile2, line)) 
  {
    std::istringstream iss(line);
    G4double value;
    int currentColumn = 1;
    while (iss >> value) 
    {
      if (currentColumn == 2) 
      {
        pyrexRefraction_ImaginaryRindex.push_back(value);
      }
      currentColumn++;
    }
  }

  G4cout << "RealRindex:" << G4endl;
  for (int i = 0; i < pyrexOpticEnergy.size(); i++) 
  {
    G4cout << pyrexOpticEnergy[i] << " " << pyrexRefraction_RealRindex[i] << G4endl;
  }

  G4cout << "ImaginaryRindex:" << G4endl;
  for (int i = 0; i < pyrexOpticEnergy.size(); i++) 
  {
    G4cout << pyrexOpticEnergy[i] << " " << pyrexRefraction_ImaginaryRindex[i] << G4endl;
  }

  inputFile1.close();
  inputFile2.close();

  std::vector<G4double> surTransmittance;
  std::vector<G4double> surSpecularLobeConstant;
  for(int i = 0; i < pyrexOpticEnergy.size(); i++)
  {
    surTransmittance.push_back(1);
    surSpecularLobeConstant.push_back(0.98);
  }

  // for (int i = 0; i < pyrexOpticEnergy.size(); i++) 
  // {
  //   G4cout << surTransmittance[i] << " " << surSpecularLobeConstant[i] << G4endl;
  // }

  //surface
  G4OpticalSurface* opPyrexSurface = new G4OpticalSurface("PyrexSurface");
  opPyrexSurface->SetType(dielectric_dielectric);
  opPyrexSurface->SetFinish(ground);
  opPyrexSurface->SetModel(unified);
  opPyrexSurface->SetSigmaAlpha(0.000001);        //斜率标准差单位rad,粗糙度

  G4MaterialPropertiesTable* opSurfaceProperties = new G4MaterialPropertiesTable();
  opSurfaceProperties->AddProperty("REALRINDEX", pyrexOpticEnergy, pyrexRefraction_RealRindex, false, true);
  opSurfaceProperties->AddProperty("IMAGINARYRINDEX", pyrexOpticEnergy, pyrexRefraction_ImaginaryRindex, false, true);
  opSurfaceProperties->AddProperty("TRANSMITTANCE", pyrexOpticEnergy, surTransmittance);
  opSurfaceProperties->AddProperty("SPECULARLOBECONSTANT", pyrexOpticEnergy, surSpecularLobeConstant);

  opPyrexSurface->SetMaterialPropertiesTable(opSurfaceProperties);

  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
  //中心处六边形排列透镜
  G4double Ccentre_x, Ccentre_y, centre_x, centre_y;
  G4double c[2*numberOfmonocapillaries + 1][2*numberOfmonocapillaries + 1] = {0};
  G4double theta[2*numberOfmonocapillaries + 1][2*numberOfmonocapillaries + 1] = {0};
  G4double theta_k = 0.;
  G4String logicVolumeName = "Monocapillary";

  for(int i = -numberOfmonocapillaries; i <= numberOfmonocapillaries; i++)
  {
    if(i%2 == 0)//i为偶数时
    {
      for(int j = -(numberOfmonocapillaries - std::abs(i)/2); j <= numberOfmonocapillaries - std::abs(i)/2; j++)
      {
        //Z轴上的monocapillary
        if(i == 0 && j == 0)
        {

          for(int h = 0; h <= n; h++)
          {
            if(h == 0)
            {
              zSection[h] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(0,0), 1.);
              zSection1[h+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(0,0), 1.);
            }
            else
              zSection[h] = G4ExtrudedSolid::ZSection(-fullLenth/2 + h*height, G4TwoVector(0,0),
                               CubicFunction(-fullLenth/2 + h*height)/CubicFunction(-fullLenth/2));
              zSection1[h+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + h*height, G4TwoVector(0,0),
                               CubicFunction(-fullLenth/2 + h*height)/CubicFunction(-fullLenth/2));
          }
          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, G4TwoVector(0,0), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, G4TwoVector(0,0), CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          // zSection[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, G4TwoVector(0,0), 1.);
          // zSection[n] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, G4TwoVector(0,0), CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);

          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          // G4LogicalVolume* logicCombinedCylinder = new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary");
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            // new G4PVPlacement(0, 
            //   G4ThreeVector(0,30.*um,0), 
            //   new G4LogicalVolume(extrudedSolidout, fLensMaterial, "Monocapillary2"),
            //   logicVolumeName + "_0_0_0",
            //   worldLV,
            //   fCheckOverlaps,
            //   0);
            // new G4PVPlacement(0, 
            //   G4ThreeVector(0,-20.*um,0), 
            //   new G4LogicalVolume(extrudedSolidin, fLensMaterial, "Monocapillary3"),
            //   logicVolumeName + "_0_0_0",
            //   worldLV,
            //   fCheckOverlaps,
            //   0);
          G4cout << "==================4=======================ooPhi=" << oiPhi*CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2)  << G4endl;
          continue;
        }
        G4cout << "==================3=======================diameterRadio*oiPhi/2=" << diameterRadio*oiPhi/2  << G4endl;
        //除中心点处单毛细管建模
        Ccentre_x = j;
        Ccentre_y = i*std::sqrt(3)/2;

        c[j + 15][i + 15] = std::sqrt(Ccentre_x*Ccentre_x + Ccentre_y*Ccentre_y);


        // /第一像限，先定位再向原点弯曲,第一像限rotateZ负的，rotateY正的,变像限要改的rotateZ与rotateY正负
        if(Ccentre_x > 0 && Ccentre_y > 0)
        {
          G4cout << "==================6=======================" << G4endl;
          theta[j + 15][i + 15] = std::atan(Ccentre_y/Ccentre_x);
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;

          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
          
        }

        //+x轴上
        if(Ccentre_x > 0 && Ccentre_y == 0)
        {
          theta[j + 15][i + 15] = 0.;
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;

          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }

        //-x轴上
        if(Ccentre_x < 0 && Ccentre_y == 0)
        {
          theta[j + 15][i + 15] = 180.*deg;
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;

          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }

        //+y轴上
        if(Ccentre_x == 0 && Ccentre_y > 0)
        {
          theta[j + 15][i + 15] = 90.*deg;
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;

          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }

        //-y轴上
        if(Ccentre_x == 0 && Ccentre_y < 0)
        {
          theta[j + 15][i + 15] = 270.*deg;
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }
        
        //第二像限改rotateZ里的(Ccentre_y/Ccentre_x)符号并其改rotateZ里的正负,X轴上方rotateX里为正
        if(Ccentre_x < 0 && Ccentre_y > 0)
        {
          theta[j + 15][i + 15] = 180.*deg - std::atan(-(Ccentre_y/Ccentre_x));
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
          }

        //第三象限
        if(Ccentre_x < 0 && Ccentre_y < 0)
        {
          theta[j + 15][i + 15] = 180.*deg + std::atan((Ccentre_y/Ccentre_x));
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                G4ThreeVector(0,0,0), 
                                                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                worldLV,
                                                fCheckOverlaps,
                                                0);
        
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
          "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }

        //第四象限
        if(Ccentre_x > 0 && Ccentre_y < 0)
        {
          theta[j + 15][i + 15] = 360.*deg - std::atan(-(Ccentre_y/Ccentre_x));
          G4cout <<"=========================================theta[j + 15][i + 15]=" << theta[j + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
          G4OpticalSurface* opticalSurface = dynamic_cast<G4OpticalSurface*>(
            PyrexSurface->GetSurface(worldPV, monocapillaryPV)
              ->GetSurfaceProperty());
          if(opticalSurface)
            opticalSurface->DumpInfo();
        }
      }
    }
    else if(i%2 != 0)//i为奇数时
    {
      //负半边,二三象限
      for(int m = -(numberOfmonocapillaries + 0.5 - std::abs(i)/2); m <= -1; m++)
      {
        G4cout << "m=" << m << G4endl;
        Ccentre_x = m + 0.5;
        Ccentre_y = i*std::sqrt(3)/2;
        c[m + 15][i + 15] = std::sqrt(Ccentre_x*Ccentre_x + Ccentre_y*Ccentre_y);
        G4cout <<"=========================================c[m + 15][i + 15]=" << c[m + 15][i + 15] << G4endl;

        //第二像限改rotateZ里的(Ccentre_y/Ccentre_x)符号并其改rotateZ里的正负,X轴上方rotateX里为正
        if(Ccentre_x < 0 && Ccentre_y > 0)
        {
          theta[m + 15][i + 15] = 180.*deg - std::atan(-(Ccentre_y/Ccentre_x));
          G4cout <<"=========================================theta[m + 15][i + 15]=" << theta[m + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(m) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }
        
        //第三象限
        if(Ccentre_x < 0 && Ccentre_y < 0)
        {
          theta[m + 15][i + 15] = 180.*deg + std::atan((Ccentre_y/Ccentre_x));
          G4cout <<"=========================================theta[m + 15][i + 15]=" << theta[m + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(m) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }

      }
      //正半边,一四象限
      for(int n1 = 1; n1 <=numberOfmonocapillaries + 0.5 - std::abs(i)/2 ; n1++)
      {
        Ccentre_x = n1 - 0.5;
        Ccentre_y = i*std::sqrt(3)/2;
        c[n1 + 15][i + 15] = std::sqrt(Ccentre_x*Ccentre_x + Ccentre_y*Ccentre_y);
        G4cout <<"=========================================c[n1 + 15][i + 15]=" << c[n1 + 15][i + 15] << G4endl;
        // /第一像限，先定位再向原点弯曲,第一像限rotateZ负的，rotateY正的,变像限要改的rotateZ与rotateY正负
        if(Ccentre_x > 0 && Ccentre_y > 0)
        {
          theta[n1 + 15][i + 15] = std::atan(Ccentre_y/Ccentre_x);
          G4cout <<"=========================================theta[n1 + 15][i + 15]=" << theta[n1 + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(n1) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }

        //第四象限
        if(Ccentre_x > 0 && Ccentre_y < 0)
        {
          theta[n1 + 15][i + 15] = 360.*deg - std::atan(-(Ccentre_y/Ccentre_x));
          G4cout <<"=========================================theta[n1 + 15][i + 15]=" << theta[n1 + 15][i + 15] << G4endl;
          //确定单管的截面信息
          for(int k = 0; k <= n; k++)
          {
            centre_x = Ccentre_x*CubicFunction(-fullLenth/2 + k*height);
            centre_y = Ccentre_y*CubicFunction(-fullLenth/2 + k*height);

            if(k == 0)
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
            }
            else
            {
              zSection[k] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
              zSection1[k+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + k*height, G4TwoVector(centre_x,centre_y),
                               CubicFunction(-fullLenth/2 + k*height)/CubicFunction(-fullLenth/2));
            }
          }

          //单管最外层管子
          G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

          zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(-fullLenth/2),Ccentre_y*CubicFunction(-fullLenth/2)), 1.);
          zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                          G4TwoVector(Ccentre_x*CubicFunction(fullLenth/2),Ccentre_y*CubicFunction(fullLenth/2)),
                                          CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
          G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
          G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
          G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + "_0_" + G4UIcommand::ConvertToString(n1) + "_" + G4UIcommand::ConvertToString(i),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
          
          G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
            "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
        }

      }
      
    }
  
  }
  //-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=





  G4double C_kij,Theta_kij,Rho_kij;
  //第偶数层的时候需要考虑+x、-x、+y和-y
  //第奇数层的时候考虑+y和-y
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~第1层的第j个正六边形~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  for (int j = 1; j <= 6; j++)
  {
      theta_k = (2*j -1)*180.*deg/6;         //第一层正六边形所在的极角
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << j << "    k=" << k << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              
              
              
              

              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                new G4PVPlacement(0, 
                  G4ThreeVector(0,0,0), 
                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                  logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                  worldLV,
                  fCheckOverlaps,
                  0);
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                 G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c1*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c1*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface);    
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                new G4PVPlacement(0, 
                  G4ThreeVector(0,0,0), 
                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                  logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                  worldLV,
                  fCheckOverlaps,
                  0);
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
  }
  
  //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~第1层的第j个正六边形~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~





  //---------------------------------------------------第2层的第j个正六边形---------------------------------------------------
  for(int j = 0; j < 12; j++)
  {
    if(j%2 == 0)  //c2[1]
    {
      theta_k = j*180.*deg/6;         
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << j << "    k=" << k << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              
              
              
              

              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
    }
    else if(j%2 != 0) //c2[0]
    {
      theta_k = j*180.*deg/6;         //第一层正六边形所在的极角
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << j << "    k=" << k << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              
              
              
              
              

              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if(l > 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                 G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c2[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c2[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName + G4UIcommand::ConvertToString(2) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
    }
  
  }
  
  //---------------------------------------------------第2层的第j个正六边形---------------------------------------------------






  //3.***************************************************第3层的第j个正六边形**************************************************************************************
  //3.1**********************************************第3层theta31,c3[1]**********************************************
  theta_k = theta31;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o3.1**********************************************第3层theta31,c3[1]**********************************************




  //3.2**********************************************第3层2Pi-theta31,c3[1]**********************************************
  theta_k = 360.*deg - theta31;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 18 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 18 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName + G4UIcommand::ConvertToString(3) + "_" + G4UIcommand::ConvertToString(18) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o3.2**********************************************第3层2Pi-theta31,c3[1]**********************************************
  //3.3**********************************************第3层Pi/6,Pi/2,......11Pi/6,c3[0]**********************************************
  for (int j = 1; j <= 6; j++)
  {
      theta_k = (2*j -1)*180.*deg/6;         //第一层正六边形所在的极角
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              
              
              
              

              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
  }
  
  //0o3.3**********************************************第3层Pi/6,Pi/2,......11Pi/6,c3[0]**********************************************
  //3.4**********************************************第3层2Pi/6,4Pi/6,......10Pi/6,c3[1]**********************************************
  for (int j = 1; j < 6; j++)
  {
    for(int v = 1; v <= 2; v++)
    {
      theta_k = 2*j*180.*deg/6 + std::pow(-1,v)*theta31;         //第一层正六边形所在的极角
      G4cout << "-1^(" << v << ")=" << std::pow(-1,v) << G4endl;
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 1e-15)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c3[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c3[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
    }
  }
  
  //0o3.4**********************************************第3层2Pi/6,4Pi/6,......10Pi/6,c3[1]**********************************************
  //***************************************************第3层的第j个正六边形****************************************************************************************




//***************************************************第4层的第j个正六边形****************************************************************************************
  //4.1**********************************************第4层Pi/6,Pi/2,......11Pi/6,c4[0]**********************************************
  for (int j = 1; j <= 6; j++)
  {
    theta_k = (2*j -1)*180.*deg/6;        
    for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
    {
      if(k%2 == 0)//i为偶数时
      {          
        G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
        for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
        {

            C_kij = std::sqrt((c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            
            
            
            
            

            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }

      }
      else if (k%2 != 0)
      {
        for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
        {
            C_kij = std::sqrt((c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

        }
        
        for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
        {
            C_kij = std::sqrt((c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }
      }
      
    }

  }
  
  //0o4.1**********************************************第4层Pi/6,Pi/2,......11Pi/6,c4[0]**********************************************
  //4.2**********************************************第4层theta41,c4[1]**********************************************
  theta_k = theta41;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o4.2**********************************************第4层theta41,c4[1]**********************************************
  //4.3**********************************************第4层2Pi-theta41,c4[1]**********************************************
  theta_k = 360.*deg - theta41;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o4.3**********************************************第4层2Pi-theta41,c4[1]**********************************************
  //4.4**********************************************第4层2Pi/6,4Pi/6,......10Pi/6,c4[1]**********************************************
  for (int j = 1; j < 6; j++)
  {
    for(int v = 1; v <= 2; v++)
    {
      theta_k = 2*j*180.*deg/6 + std::pow(-1,v)*theta41; 
      G4cout << "-1^(" << v << ")=" << std::pow(-1,v) << G4endl;
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c4[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c4[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
    }
  }
  
  //0o4.4**********************************************第4层2Pi/6,4Pi/6,......10Pi/6,c4[1]**********************************************
  //4.5**********************************************第4层0,2Pi/6,4Pi/6,......10Pi/6,c4[2]**********************************************
  for (int j = 0; j < 6; j++)
  {
    theta_k = 2*j*180.*deg/6;        
    for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
    {
      if(k%2 == 0)//i为偶数时
      {          
        G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
        for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
        {

            C_kij = std::sqrt((c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            
            
            
            
            

            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }

      }
      else if (k%2 != 0)
      {
        for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
        {
            C_kij = std::sqrt((c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

        }
        
        for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
        {
            C_kij = std::sqrt((c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c4[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c4[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }
      }
      
    }

  }
  
  //0o4.5**********************************************第4层0,2Pi/6,4Pi/2,......10Pi/6,c4[2]**********************************************
//***************************************************第4层的第j个正六边形****************************************************************************************





//***************************************************第5层的第j个正六边形****************************************************************************************
  //5.1**********************************************第5层Pi/6,Pi/2,......11Pi/6,c5[0]**********************************************
  for (int j = 1; j <= 6; j++)
  {
    theta_k = (2*j -1)*180.*deg/6;        
    for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
    {
      if(k%2 == 0)//i为偶数时
      {          
        G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
        for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
        {

            C_kij = std::sqrt((c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            
            
            
            
            

            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                    G4ThreeVector(0,0,0), 
                                                    new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                    logicVolumeName,
                                                    worldLV,
                                                    fCheckOverlaps,
                                                    0);
              
              G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }

      }
      else if (k%2 != 0)
      {
        for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
        {
            C_kij = std::sqrt((c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

        }
        
        for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
        {
            C_kij = std::sqrt((c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c5[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }
      }
      
    }

  }
  
  //0o5.1**********************************************第5层Pi/6,Pi/2,......11Pi/6,c5[0]**********************************************
  //5.2**********************************************第5层theta51,c5[1]**********************************************
  theta_k = theta51;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o5.2**********************************************第5层theta51,c5[1]**********************************************
  //5.3**********************************************第5层2Pi-theta51,c5[1]**********************************************
  theta_k = 360.*deg - theta51;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o5.3**********************************************第5层2Pi-theta51,c5[1]**********************************************
  //5.4**********************************************第5层2Pi/6,4Pi/6,......10Pi/6,c5[1]**********************************************
  for (int j = 1; j < 6; j++)
  {
    for(int v = 1; v <= 2; v++)
    {
      theta_k = 2*j*180.*deg/6 + std::pow(-1,v)*theta51; 
      G4cout << "-1^(" << v << ")=" << std::pow(-1,v) << G4endl;
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
    }
  }
  
  //0o5.4**********************************************第5层2Pi/6,4Pi/6,......10Pi/6,c5[1]**********************************************
  //5.5**********************************************第5层theta52,c5[2]**********************************************
  theta_k = theta52;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o5.5**********************************************第5层theta52,c5[2]**********************************************
  //5.6**********************************************第5层2Pi-theta52,c5[2]**********************************************
  theta_k = 360.*deg - theta52;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o5.6**********************************************第5层2Pi-theta52,c5[2]**********************************************
  //5.7**********************************************第5层2Pi/6,4Pi/6,......10Pi/6,c5[2]**********************************************
  for (int j = 1; j < 6; j++)
  {
    for(int v = 1; v <= 2; v++)
    {
      theta_k = 2*j*180.*deg/6 + std::pow(-1,v)*theta52; 
      G4cout << "-1^(" << v << ")=" << std::pow(-1,v) << G4endl;
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  else
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 1.*um, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um))*std::sin(Theta_kij), 1.);
                zSection[n] = G4ExtrudedSolid::ZSection(fullLenth/2 + 1.*um, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um))*std::sin(Theta_kij),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c5[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c5[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
    }
  }
  
  //0o5.7**********************************************第5层2Pi/6,4Pi/6,......10Pi/6,c5[2]**********************************************
//***************************************************第5层的第j个正六边形****************************************************************************************






//***************************************************第6层的第j个正六边形****************************************************************************************
  //6.1**********************************************第6层Pi/6,Pi/2,......11Pi/6,c6[0]**********************************************
  for (int j = 1; j <= 6; j++)
  {
    theta_k = (2*j -1)*180.*deg/6;        
    for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
    {
      if(k%2 == 0)//i为偶数时
      {          
        G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
        for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
        {

            C_kij = std::sqrt((c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            
            
            
            
            

            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }

      }
      else if (k%2 != 0)
      {
        for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
        {
            C_kij = std::sqrt((c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

        }
        
        for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
        {
            C_kij = std::sqrt((c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[0]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[0]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }
      }
      
    }

  }
  
  //0o6.1**********************************************第6层Pi/6,Pi/2,......11Pi/6,c6[0]**********************************************
  //6.2**********************************************第5层theta61,c6[1]**********************************************
  theta_k = theta61;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o6.2**********************************************第6层theta61,c6[1]**********************************************
  //6.3**********************************************第6层2Pi-theta61,c6[1]**********************************************
  theta_k = 360.*deg - theta61;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
            G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                  G4ThreeVector(0,0,0), 
                                                  new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                  logicVolumeName,
                                                  worldLV,
                                                  fCheckOverlaps,
                                                  0);
            
            G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
              "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o6.3**********************************************第6层2Pi-theta61,c6[1]**********************************************
  //6.4**********************************************第6层2Pi/6,4Pi/6,......10Pi/6,c6[1]**********************************************
  for (int j = 1; j < 6; j++)
  {
    for(int v = 1; v <= 2; v++)
    {
      theta_k = 2*j*180.*deg/6 + std::pow(-1,v)*theta61; 
      G4cout << "-1^(" << v << ")=" << std::pow(-1,v) << G4endl;
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[1]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[1]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
    }
  }
  
  //0o6.4**********************************************第6层2Pi/6,4Pi/6,......10Pi/6,c6[1]**********************************************
  //6.5**********************************************第6层theta62,c6[2]**********************************************
  theta_k = theta62;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o6.5**********************************************第6层theta62,c6[2]**********************************************
  //6.6**********************************************第6层2Pi-theta62,c6[2]**********************************************
  theta_k = 360.*deg - theta62;         
  for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
  {
    if(k%2 == 0)//i为偶数时
    {          
      G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3  <<  "   order=" << 1 << "    k=" << k << G4endl;
      for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
      {

          C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3<< "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }

    }
    else if (k%2 != 0)
    {
      for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
      {
          C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

      }
      for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
      {
          C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                    (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                    (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
          G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
          //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
          if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
            Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }

          else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
          {
            G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
            if(l == 0)
              Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else if (l < 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
            Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
            if(k == 0)
              Theta_kij = 180.*deg;
            else if(k > 0)
              Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
            Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
            if(l == 0)
              Theta_kij = 270.*deg;
            else if (l < 0)
              Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
          {
            G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
            Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                          (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
          }
          else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
          {
            G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
            if(k == 0)
              Theta_kij = 360.*deg;
            else if (k < 0)
              Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            else
              Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
          }
          G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
          G4cout << "~~~~~~~~~~~~~~~~~~~C_" << 3 << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << 3 << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
          
          //单管在第一象限
          if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //在+y
          else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //2象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }

          //-x轴
          else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //3象限
          else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //-y
          else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //4象限
          else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
          //+x
          else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
          {
            //确定单管的截面信息
            for(int m = 0; m <= n; m++)
            {
              Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
              centre_x = Rho_kij*std::cos(Theta_kij);
              centre_y = Rho_kij*std::sin(Theta_kij);

              if(m == 0)
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
              }
              else
              {
                zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
              }
                

            }

            //单管最外层管子
            G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

            zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
            zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                            G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                            CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
            G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
            G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
            G4cout << "Monocapillary_3_" << 1 << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
          }
      }
    }
    
  }
  
  //0o6.6**********************************************第6层2Pi-theta62,c62]**********************************************
  //6.7**********************************************第6层2Pi/6,4Pi/6,......10Pi/6,c6[2]**********************************************
  for (int j = 1; j < 6; j++)
  {
    for(int v = 1; v <= 2; v++)
    {
      theta_k = 2*j*180.*deg/6 + std::pow(-1,v)*theta62; 
      G4cout << "-1^(" << v << ")=" << std::pow(-1,v) << G4endl;
      for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
      {
        if(k%2 == 0)//i为偶数时
        {          
          G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
          for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
          {

              C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }

        }
        else if (k%2 != 0)
        {
          for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
          {
              C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

          }
          
          for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
          {
              C_kij = std::sqrt((c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                        (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                        (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                        (c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
              G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
              //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
              if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
                Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }

              else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
              {
                G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
                if(l == 0)
                  Theta_kij = std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else if (l < 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
                Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 180.*deg;
                else if(k > 0)
                  Theta_kij = 180.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
                Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
                if(l == 0)
                  Theta_kij = 270.*deg;
                else if (l < 0)
                  Theta_kij = 180.*deg + std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
              {
                G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
                Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              }
              else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
              {
                G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
                if(k == 0)
                  Theta_kij = 360.*deg;
                else if (k < 0)
                  Theta_kij = 360.*deg - std::abs(std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
                else
                  Theta_kij = std::atan((c6[2]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                                (c6[2]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
              }
              G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
              G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
              
              //单管在第一象限
              if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //在+y
              else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //2象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }

              //-x轴
              else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //3象限
              else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //-y
              else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //4象限
              else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
              //+x
              else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
              {
                //确定单管的截面信息
                for(int m = 0; m <= n; m++)
                {
                  Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                  centre_x = Rho_kij*std::cos(Theta_kij);
                  centre_y = Rho_kij*std::sin(Theta_kij);

                  if(m == 0)
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  }
                  else
                  {
                    zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                    zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                    CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  }
                    

                }

                //单管最外层管子
                G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

                zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(-fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2)*std::sin(Theta_kij)), 1.);
                zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                                G4TwoVector(C_kij*CubicFunction(fullLenth/2)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2)*std::sin(Theta_kij)),
                                                CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
                
                G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
                G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
                G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
              }
          }
        }
        
      }
  
    }
  }
  
  //0o6.7**********************************************第6层2Pi/6,4Pi/6,......10Pi/6,c6[2]**********************************************
  //6.8**********************************************第6层0,2Pi/6,4Pi/6,......10Pi/6,c6[3]**********************************************
  for (int j = 0; j < 6; j++)
  {
    theta_k = 2*j*180.*deg/6;        
    for(int k = -numberOfmonocapillaries; k <= numberOfmonocapillaries; k++)  //正六边形第k行，y标号
    {
      if(k%2 == 0)//i为偶数时
      {          
        G4cout << "~~~~~~~~~~~~~~~~~~~layer=" << 3 << "    j=" << 2*j << G4endl;
        for(int l = -(numberOfmonocapillaries - std::abs(k)/2); l <= numberOfmonocapillaries - std::abs(k)/2; l++)  //正六边形第l列，x标号
        {

            C_kij = std::sqrt((c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            
            
            
            
            

            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
                G4VPhysicalVolume*  monocapillaryPV = new G4PVPlacement(0, 
                                                      G4ThreeVector(0,0,0), 
                                                      new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                                                      logicVolumeName,
                                                      worldLV,
                                                      fCheckOverlaps,
                                                      0);
                
                G4LogicalBorderSurface* PyrexSurface = new G4LogicalBorderSurface(
                  "PyrexSurface", worldPV, monocapillaryPV, opPyrexSurface); 
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }

      }
      else if (k%2 != 0)
      {
        for(int l = -(numberOfmonocapillaries + 0.5 - std::abs(k)/2); l <= -1; l++)
        {
            C_kij = std::sqrt((c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

        }
        
        for(int l = 1; l <=numberOfmonocapillaries + 0.5 - std::abs(k)/2; l++)
        {
            C_kij = std::sqrt((c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))*
                      (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])) + 
                      (c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))*
                      (c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15])));
            G4cout << "~~~~~~~~~~~~~~~~~~~std::cos(theta_k)"<<std::cos(theta_k)<<"     std::sin(theta_k)"<<k<<"+15]="<<std::sin(theta_k)<< G4endl;
            //根据每根管子所在位置计算Theta_kij，范围：0～2Pi
            if(std::cos(theta_k) > 1e-15 && std::sin(theta_k) > 1e-15)//正六边形在第一象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~1象限" << G4endl;
              Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }

            else if(std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) > 0)//在+y轴上
            {
              G4cout << "~~~~~~~~~~~~~~~~~~y轴" << G4endl;
              if(l == 0)
                Theta_kij = std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else if (l < 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) > 1e-15)//在第二象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~2象限" << G4endl;
              Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在-x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-x轴" << G4endl;
              if(k == 0)
                Theta_kij = 180.*deg;
              else if(k > 0)
                Theta_kij = 180.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) < -1e-15 && std::sin(theta_k) < -1e-15)//在第三象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~3象限" << G4endl;
              Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > -1e-15 && std::cos(theta_k) < 1e-15 && std::sin(theta_k) < 0)//在-y轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~-y轴" << G4endl;
              if(l == 0)
                Theta_kij = 270.*deg;
              else if (l < 0)
                Theta_kij = 180.*deg + std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 1e-15 && std::sin(theta_k) < -1e-15)//在第四象限
            {
              G4cout << "~~~~~~~~~~~~~~~~~~4象限" << G4endl;
              Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                            (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
            }
            else if (std::cos(theta_k) > 0 && std::sin(theta_k) > -1e-15 && std::sin(theta_k) < 1e-15)//在+x轴
            {
              G4cout << "~~~~~~~~~~~~~~~~~~+x轴" << G4endl;
              if(k == 0)
                Theta_kij = 360.*deg;
              else if (k < 0)
                Theta_kij = 360.*deg - std::abs(std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15]))));
              else
                Theta_kij = std::atan((c6[3]*std::sin(theta_k) + c[l+15][k+15]*std::sin(theta[l+15][k+15]))/
                              (c6[3]*std::cos(theta_k) + c[l+15][k+15]*std::cos(theta[l+15][k+15])));
            }
            G4cout << "~~~~~~~~~~~~~~~~~~~c["<<l<<"+15]["<<k<<"+15]="<<c[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~theta["<<l<<"+15]["<<k<<"+15]="<<theta[l+15][k+15]<< G4endl;
            G4cout << "~~~~~~~~~~~~~~~~~~~C_" << j << "_" << l << "_" << k << "=" << C_kij << "     Theta_" << j << "_" << l << "_" << k << "=" << Theta_kij << G4endl;
            
            //单管在第一象限
            if(std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) > 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //在+y
            else if(std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //2象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) > 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }

            //-x轴
            else if (std::cos(Theta_kij) < 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //3象限
            else if (std::cos(Theta_kij) < -1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //-y
            else if (std::cos(Theta_kij) > -1e-15 && std::cos(Theta_kij) < 1e-15 && std::sin(Theta_kij) < 0)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //4象限
            else if (std::cos(Theta_kij) > 1e-15 && std::sin(Theta_kij) < -1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
            //+x
            else if (std::cos(Theta_kij) > 0 && std::sin(Theta_kij) > -1e-15 && std::sin(Theta_kij) < 1e-15)
            {
              //确定单管的截面信息
              for(int m = 0; m <= n; m++)
              {
                Rho_kij = C_kij*CubicFunction(-fullLenth/2 + m*height);
                centre_x = Rho_kij*std::cos(Theta_kij);
                centre_y = Rho_kij*std::sin(Theta_kij);

                if(m == 0)
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2, G4TwoVector(centre_x,centre_y), 1.);
                }
                else
                {
                  zSection[m] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                  zSection1[m+1] = G4ExtrudedSolid::ZSection(-fullLenth/2 + m*height, G4TwoVector(centre_x,centre_y),
                                  CubicFunction(-fullLenth/2 + m*height)/CubicFunction(-fullLenth/2));
                }
              }

              //单管最外层管子
              G4ExtrudedSolid* extrudedSolidout = new G4ExtrudedSolid("myoutExtrudedSolid", twovector1, zSection);

              zSection1[0] = G4ExtrudedSolid::ZSection(-fullLenth/2 - 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(-fullLenth/2 - 1.*um)*std::sin(Theta_kij)), 1.);
              zSection1[n+2] = G4ExtrudedSolid::ZSection(fullLenth/2 + 10.*mm, 
                                              G4TwoVector(C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::cos(Theta_kij),C_kij*CubicFunction(fullLenth/2 + 1.*um)*std::sin(Theta_kij)),
                                              CubicFunction(fullLenth/2)/CubicFunction(-fullLenth/2));
              G4ExtrudedSolid* extrudedSolidin = new G4ExtrudedSolid("myinExtrudedSolid", twovector2, zSection1);
              G4SubtractionSolid* monocapillary = new G4SubtractionSolid("Monocapillary", extrudedSolidout, extrudedSolidin);
              new G4PVPlacement(0, 
                G4ThreeVector(0,0,0), 
                new G4LogicalVolume(monocapillary, fLensMaterial, "Monocapillary"),
                logicVolumeName + G4UIcommand::ConvertToString(1) + "_" + G4UIcommand::ConvertToString(j) + "_" + G4UIcommand::ConvertToString(l) + "_" + G4UIcommand::ConvertToString(k),
                worldLV,
                fCheckOverlaps,
                0);
              G4cout << "Monocapillary_1_" << j << "_" << l << "_" << k << "~~~~~~~~~~~~~~~~~~~is placed~~~~~~~~~~~~~~~~~~~"<< G4endl;
            }
        }
      }
      
    }


  }
  
  //0o6.8**********************************************第6层0,2Pi/6,4Pi/2,......10Pi/6,c6[3]**********************************************


//***************************************************第6层的第j个正六边形****************************************************************************************
  return worldPV;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void OpNoviceDetectorConstruction::SetDumpGdml(G4bool val) { fDumpGdml = val; }

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
G4bool OpNoviceDetectorConstruction::IsDumpGdml() const { return fDumpGdml; }

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void OpNoviceDetectorConstruction::SetVerbose(G4bool val) { fVerbose = val; }

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
G4bool OpNoviceDetectorConstruction::IsVerbose() const { return fVerbose; }

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void OpNoviceDetectorConstruction::SetDumpGdmlFile(G4String filename)
{
  fDumpGdmlFileName = filename;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
G4String OpNoviceDetectorConstruction::GetDumpGdmlFile() const
{
  return fDumpGdmlFileName;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
void OpNoviceDetectorConstruction::PrintError(G4String ed)
{
  G4Exception("OpNoviceDetectorConstruction:MaterialProperty test", "op001",
              FatalException, ed);
}
